<!--
Google IO 2012 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mahe <lukem@google.com>

URL: https://code.google.com/p/io-2012-slides
-->
<!DOCTYPE html>
<html>
<head>
  <title>Esercizi 2015</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="all" href="theme/css/tomamic.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen">

<slide class="title-slide segue nobackground">
  <aside class="gdbar"><img src="images/logo.png"></aside>
  <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
  <h1 data-config-title><!-- populated from slide_config.json --></h1>
  <figure><img src="images/misc/geek-girl.jpg"></figure>
  <hgroup>
    <h2>Introduzione alla programmazione</h2>
    <p>Michele Tomaiuolo<br>Ingegneria dell'Informazione, UniPR</p>
  </hgroup>
</slide>


<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 1</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>1.1 Hello, user!</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/handshake.png">
        
      </figure><ul>
<li>Compilare ed eseguire il programma “<code>Hello world</code>”</li>
<li>In una versione successiva del programma...</li>
<li>Chiedere il nome all'utente e aggiungere tale nome al messaggio di saluto</li>
<li>Se il nome dell'utente è “<code>admin</code>”, mostrare inoltre il messaggio speciale “<code>At your command</code>”</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.2 Equazione di secondo grado</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/quadratic-eq.svg"><img src="images/misc/quadratic-formula.svg">
        
      </figure><ul>
<li>Chiedere all'utente i tre coefficienti di una equazione di secondo grado<ul>
<li><code>ax<sup>2</sup> + bx + c = 0</code></li>
</ul>
</li>
<li>Comunicare all'utente che tipo di soluzioni presenta l'equazione<ul>
<li>Due soluzioni reali</li>
<li>Un'unica soluzione reale</li>
<li>Nessuna soluzione reale</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Non è richiesto il valore delle soluzioni</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.3 Equazione di 2° grado, con ciclo</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/quadratic-eq.svg"><img src="images/misc/quadratic-formula.svg">
        
      </figure><ul>
<li>Riprendere l'esercizio 1.2</li>
<li>In caso di soluzioni reali, mostrare all'utente il loro valore</li>
<li>Chiedere infine all'utente se vuole valutare un'altra equazione</li>
</ul>
<blockquote></blockquote>
<p>Racchiudere il programma in un ciclo <code>while</code> <br>
Per il calcolo della radice quadrata, utilizzare <code>math.sqrt(...)</code> <br>
All'inizio del programma: <code>import math</code></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.4 Fattoriale</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Leggere un numero intero positivo <code>n</code></li>
<li>Calcolare il fattoriale del numero</li>
</ul>
<blockquote></blockquote>
<p>Moltiplicare tra loro i primi <code>n</code> numeri</p>
<p>Memorizzare in una variabile il risultato parziale, ad ogni ciclo, moltiplicarla per il nuovo numero</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.5 Divisori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Chiedere all'utente un numero <code>n</code></li>
<li>Trovare tutti i divisori di <code>n</code></li>
</ul>
<blockquote></blockquote>
<p><code>n</code> è divisibile per <code>x</code> se <code>n % x == 0</code></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.6 Sequenza di valori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Leggere, attraverso un ciclo, una sequenza di numeri interi inseriti dall'utente</li>
<li>La sequenza termina quando il loro prodotto supera 1000</li>
<li>Visualizzare il numero di valori inseriti e il loro prodotto</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.7 Massimo e minimo</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/data-sequence.png">
        
      </figure><ul>
<li>Leggere, attraverso un ciclo, una sequenza di numeri interi</li>
<li>La sequenza termina quando l'utente inserisce il valore 0</li>
<li>Visualizzare il valore massimo e quello minimo tra i numeri inseriti</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.8 Passeggiata casuale</h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>code: python</p>
<ul>
<li>Chidere alluntente un numero <code>n</code></li>
<li>A partire dalla posizione <code>x = 0, y = 0</code></li>
<li>Compiere <code>n</code> passi, ciascuno in una direzione casuale<ul>
<li>Estrarre un numero casuale <code>r</code> tra 0 e 3</li>
<li>Se <code>r == 0</code>, sottrarre 1 alla <code>y</code> attuale (alto)</li>
<li>Se <code>r == 1</code>, sommare 1 alla <code>x</code> attuale (destra)</li>
<li>Se <code>r == 2</code>, sommare 1 alla <code>y</code> attuale (basso)</li>
<li>Se <code>r == 3</code>, sottrarre 1 alla <code>x</code> attuale (sinistra)</li>
</ul>
</li>
<li>
<p>Al termine comunicare la distanza raggiunta dall'origine, calcolata come <code>x + y</code></p>
<p>from random import randrange</p>
<h1>...</h1>
<p>direction = randrange(4)  # something between 0 and 3</p>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.9 Tre carte</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/three-cards.png">
        
      </figure><ul>
<li>All'inizio l'utente ha 10 monete</li>
<li>Ad ogni turno:<ul>
<li>Viene estratto a sorte un numero segreto tra 1 e 3</li>
<li>L'utente sceglie quante monete puntare e su quale numero</li>
<li>Se indovina, gli viene sommato l'importo puntato</li>
<li>Altrimenti gli viene sottratto lo stesso importo</li>
</ul>
</li>
<li>Il gioco termina quando l'utente perde tutto o si ritira</li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 2</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>2.1 Percentuale di maiuscole</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/troll-key.png">
        
      </figure><ul>
<li>Chiedere una riga di testo all'utente</li>
<li>Mostrare la percentuale di lettere maiuscole presenti</li>
</ul>
<blockquote></blockquote>
<p>Usare un ciclo <code>for</code> sulla stringa</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.2 Valori sopra e sotto la media</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Chiedere all'utente una sequenza in interi, terminata da 0</li>
<li>Calcolare e mostrare il valore medio</li>
<li>Elencare i valori sotto alla media</li>
<li>Elencare i valori sopra (o uguali) alla media</li>
</ul>
<blockquote></blockquote>
<p>Aggiungere ciascun valore ad una lista inizialmente vuota, con <code>append</code></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.3 Funzione, Erone</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/triangle-notations.svg">
        
      </figure><ul>
<li>Definire una funzione <code>heron</code> per il calcolo dell'area di un triangolo<ul>
<li>Parametri: tre lati come <code>float</code></li>
<li>Risultato: area come <code>float</code></li>
</ul>
</li>
<li>Invocare la funzione dalla shell interattiva</li>
<li>Aggiungere poi al programma una funzione <code>main</code><ul>
<li><em>Procedura, senza parametri e senza risultato</em></li>
<li>Chiedere all'utente tre valori (chiamando <code>input</code>)</li>
<li>Poi chiamare <code>heron</code> con questi parametri</li>
<li>Infine mostrare all'utente il risultato (chiamando <code>print</code>)</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Formula di Erone: <code>area = sqrt(s * (s - a) * (s - b) * (s - c))</code> <br>
Con <code>s = (a + b + c) / 2</code>, semiperimetro</p>
<p><a href="http://en.wikipedia.org/wiki/Heron%27s_formula">http://en.wikipedia.org/wiki/Heron%27s_formula</a></p>
<p><code>sqrt</code> in modulo <code>math</code></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.4 Sequenza di quadrati</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/green-squares.png">
        
      </figure><ul>
<li>Chiedere all'utente il numero di quadrati da disegnare</li>
<li>Disegnare i quadrati con lato decrescente, tutti allineati in alto e a sinistra</li>
<li>Far variare il colore dei quadrati<ul>
<li>Dal nero del quadrato più grande</li>
<li>Fino al verde del quadrato più piccolo</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Cominciare a disegnare un grosso quadrato nero</p>
<p>Poi, inserire l'operazione di disegno un ciclo, aggiungendo ad ogni passo <code>10</code> (p.es.) al livello di verde, e togliendo lo stesso valore al lato</p>
<p>Infine, determinare automaticamente le variazioni migliori per lato e colore, prima di iniziare il ciclo</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.5 Griglia di colori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/color-grid.png"><img src="images/oop/raster-tile.png">
        
      </figure><ul>
<li>Chidere all'utente dei valori per <code>rows</code> e <code>cols</code></li>
<li>Mostrare una griglia di rettangoli di dimensione <code>rows×cols</code></li>
<li>Partire da un rettangolo nero in alto a sinistra</li>
<li>In orizzontale, aumentare gradatamente la componente di blu</li>
<li>In verticale, aumentare gradatamente la componente di verde</li>
</ul>
<blockquote></blockquote>
<p>Cominciare a creare una griglia di riquadri tutti neri, con due cicli <code>for</code> annidati</p>
<p>Lasciare tra i riquadri un piccolo margine</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.6 Triangolo di cifre</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Leggere un numero intero positivo <code>n</code> (&lt; 10)</li>
<li>Per ciascun valore <code>y</code> tra 1 ed <code>n</code>...</li>
<li>Stampare una riga con le cifre da 1 ad <code>y</code></li>
</ul>
<pre class="prettyprint" data-lang="Output"><code>1
12
123
1234
</code></pre>
<p>Usare due cicli for annidati <br>
All'inizio non considerare <code>n</code>, ma fissare <code>y</code> e scrivere una sola riga: <code>y = 3</code> → <code>“123”</code> <br>
Poi racchiudere tutto in un ciclo for esterno</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.7 Nomi sopra e sotto la media</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Chiedere all'utente una sequenza di dati<ul>
<li>Ciascun nome (<code>str</code>) è associato ad un valore (<code>int</code>)</li>
<li>La sequenza termina quando il nome è vuoto</li>
</ul>
</li>
<li>Calcolare e mostrare il valore medio</li>
<li>Elencare i nomi con valori sotto alla media</li>
<li>Elencare i nomi con valori sopra (o uguali) alla media</li>
</ul>
<blockquote></blockquote>
<p>Inserire nella lista delle tuple (coppie nome/valore)</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.8 Istogramma con barre orizzontali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/histogram-rot.png">
        
      </figure><ul>
<li>Chiedere all'utente una lista di valori positivi<ul>
<li>La lista termina quando l'utente inserisce il valore <code>0</code></li>
</ul>
</li>
<li>Mostrare un istogramma<ul>
<li>Larghezza di ciascuna barra proporzionale al valore corrispondente</li>
<li>La barra più lunga occupa tutto lo spazio disponibile</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.9 Istogramma con barre verticali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/histogram.png">
        
      </figure><ul>
<li>Chiedere all'utente una lista di valori positivi<ul>
<li>La lista termina quando l'utente inserisce il valore <code>0</code></li>
</ul>
</li>
<li>Mostrare un istogramma<ul>
<li>Altezza di ciascuna barra proporzionale al valore corrispondente</li>
<li>La barra più alta occupa tutto lo spazio disponibile</li>
<li>Barre in blu, per valori sotto alla media</li>
<li>Barre in rosso, per valori sopra (o uguali) alla media</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 3</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>3.1 Classe dei pianeti</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Scrivere una classe <code>Planet</code> per rappresentare dei pianeti</li>
<li>Dati: raggio (<code>float</code>), colore (tupla rgb)</li>
<li>Il costruttore riceve tutti i dati necessari</li>
<li>Fornire due metodi pubblici (<em>getter</em>) per ottenere il raggio e il colore</li>
<li>Fornire un metodo pubblico <code>area</code> che restituisce la superficie (<code>float</code>): <code>4 * pi * (r ** 2)</code></li>
<li>Fornire un metodo pubblico <code>volume</code> che restituisce il volume (<code>float</code>): <code>(4 / 3) * pi * (r ** 3)</code></li>
<li>Nella parte principale del programma:<ul>
<li>Creare un oggetto cerchio, con dati forniti all'utente</li>
<li>Invocare i metodi <code>area</code> e <code>volume</code> e mostrare i risultati</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Distinguere bene campi dell'oggetto, parametri dei metodi, variabili esterne</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.2 Pianeta in rivoluzione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Aggiungere alla classe <code>Planet</code> i seguenti campi<ul>
<li>Posizione del centro in coordinate polari: raggio e angolo</li>
<li>Velocità angolare: di quanti gradi/radianti si sposta il pianeta ad ogni turno</li>
</ul>
</li>
<li>Aggiungere alla classe <code>Planet</code> i seguenti metodi<ul>
<li><code>move</code>: il pianeta si sposta di un piccolo arco attorno all'origine <code>(0 ,0)</code></li>
<li><code>pos</code>: restituisce la posizione attuale del pianeta come tupla <code>(x, y)</code></li>
</ul>
</li>
<li>Nel programma principale, creare un pianeta e ciclicamente spostarlo<ul>
<li>Chiamare il metodo <code>move</code> del pianeta</li>
<li>Visualizzare la posizione aggiornata ottenuta tramite il metodo <code>pos</code></li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p><code>x = r * cos(theta), y = r * sin(theta)</code></p>
<p><code>sin, cos</code> in modulo <code>math</code> (operano in radianti)</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.3 Movimento orizzontale ciclico</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/frogger.png">
        
      </figure><ul>
<li>Partire dal classico ciclo di una applicazione <em>PyGame</em></li>
<li>Fare in modo che un rettangolo si muova orizzontalmente sullo schermo, avanzando di <code>10</code> pixel alla volta<ul>
<li>Gestire sia il movimento verso destra che verso sinistra, a seconda del segno di una costante <code>dx</code></li>
</ul>
</li>
<li>Partire dalla posizione <code>x = 100, y = 10</code></li>
<li>Seguire un percorso ciclico<ul>
<li>Quando il rettangolo esce dallo schermo, rientra dalla parte opposta</li>
</ul>
</li>
<li><em>Opzionalmente</em>, fare in modo che lo spostamento sia calcolato in una <em>funzione</em>, con gli opportuni parametri<ul>
<li>Non usare alcuna variabile globale</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.4 Movimento di un pianeta</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Partire dal classico ciclo di una applicazione <em>PyGame</em></li>
<li>Rappresentare il movimento del pianeta dell'esercizio 3.2<ul>
<li>Per ogni frame, chiamare il metodo <code>move</code> del pianeta</li>
<li>Rappresentare un cerchio nella posizione aggiornata del pianeta</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Fare in modo che l'origine degli assi sia al centro della finestra <br>
L'asse <em>y</em> può rimanere orientato verso il basso</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.5 Lista di pianeti</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Partire dall'esercizio precedente</li>
<li>Anzichè un solo pianeta, crearne diversi ed inserirli in una lista</li>
<li>Rappresentare il movimento di tutti i pianeti<ul>
<li>Per ogni frame, in un ciclo <code>for</code>, chiamare il metodo <code>move</code> di ogni pianeta</li>
<li>Rappresentare un cerchio nella posizione aggiornata di ogni pianeta</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.6 Classe del sistema solare</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><code>move_all</code></li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.7 Scrittura di risultati casuali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/dice.png">
        
      </figure><ul>
<li>Simulare <code>n</code> lanci di una coppia di dadi<ul>
<li><code>n</code> scelto dall'utente</li>
</ul>
</li>
<li>Scrivere il risultato dei lanci in un file<ul>
<li>In ogni riga, inserire i due valori separati da spazio</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.8 Lettura di risultati casuali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/dice.png">
        
      </figure><ul>
<li>Leggere i dati dal file generato nell'esercizio 3.6</li>
<li>Per ogni coppia di valori letta, mostrare all'utente la loro somma</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.9 Analisi di risultati casuali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/dice.png">
        
      </figure><ul>
<li>Leggere i dati dal file generato nell'esercizio 3.6</li>
<li>Contare quante volte si presenta ciascun risultato<ul>
<li>Risultati possibili: da 2 a 12</li>
<li>Somma dei due dadi</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Per conteggiare i vari risultati, usare una lista di (almeno) 11 valori</p></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 4</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>4.1 Massimo valore, con ricorsione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/fun/matryoshka.png">
        
      </figure><ul>
<li>Cercare il carattere con codice Unicode maggiore in un testo</li>
<li>Definire una funzione ricorsiva <code>max_char</code></li>
<li>Se il testo ha lunghezza 1, l'unico carattere è quello maggiore</li>
<li>Altrimenti il carattere maggiore è pari al massimo tra:<ul>
<li>Il primo carattere</li>
<li>Il carattere maggiore tra tutti gli altri (ricorsione)</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.2 Pallina in caduta</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Creare una classe <code>FallingBall</code><ul>
<li>Partire dall'esempio visto a lezione</li>
<li>Campi privati: <code>x</code>, <code>y</code>, <code>dx</code>, <code>dy</code></li>
<li>Metodo <code>move</code>, per avanzare (con rimbalzo sui bordi)</li>
<li>Metodo <code>rect</code>, per ottenere la posizione attuale</li>
</ul>
</li>
<li>Aggiungere un campo <code>g</code> per la gravità (<code>float</code>)<ul>
<li>Accelerazione costante verso il basso</li>
<li>Ad ogni esecuzione, il metodo <code>move</code> aggiunge <code>g</code> a <code>dy</code></li>
</ul>
</li>
<li>Istanziare un oggetto <code>FallingBall</code> e farlo muovere sullo schermo<ul>
<li>Chiamare il metodo <code>move</code> ad ogni ciclo</li>
<li>Visualizzare un rettangolo nella posizione corrispondente</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.3 Attori astratti</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Definire una classe base <code>Actor</code><ul>
<li>Metodo astratto <code>move</code></li>
<li>Metodo astratto <code>rect</code></li>
</ul>
</li>
<li>Ridefinire <code>FallingBall</code> (es. 4.2) come sottoclasse di <code>Actor</code></li>
<li>Definire una classe <code>Plane</code>, come sottoclasse di <code>Actor</code><ul>
<li>Riprodurre il movimento orizzontale ciclico dell'esercizio 3.3</li>
</ul>
</li>
<li>Nel programma principale, creare una lista di personaggi misti (palline e aerei)<ul>
<li>Chiamare il metodo <code>move</code> di ciascuno ad ogni ciclo</li>
<li>Visualizzare un rettangolo nella posizione corrispondente</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.4 Scroll</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Associare a ciasscun tipo di personaggio dell'es. 4.3 una immagine</li>
<li>Assegnare ai personaggi un'area di movimento più ampia della finestra</li>
<li>Usare per lo sfondo una immagine grande quanto l'intera area di movimento</li>
<li>Permettere infine all'utente di spostare l'inquadratura assegnata alla finestra, usando i tasti cursore</li>
</ul>
<blockquote></blockquote>
<p>Non modificare le classi dei personaggi, ma aggiugere un offset alle loro coordinate per decidere il punto in cui visualizzarli nella finestra</p>
<p>Usare lo stesso offset anche per ritagliare la parte giusta dall'immagine di sfondo </p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.5 Circular infinity</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/crop-circle.jpg">
        
      </figure><ul>
<li>Disegnare ricorsivamente dei cerchi, con i centri allineati in verticale</li>
<li>Il riquadro iniziale è l'intera finestra</li>
<li>Tracciare un cerchio contenuto nel riquadro <code>(x, y, w, h)</code><ul>
<li><code>r = h / 2, xc = w / 2, yc = y + h / 2</code></li>
</ul>
</li>
<li>Dividere il riquadro in due metà</li>
<li>Applicare a ciascuno dei due riquadri il processo, ricorsivamente</li>
<li>Ad ogni livello, invertire il colore del cerchio disegnato</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.6 Tris</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/tic-tac-toe.svg">
        
      </figure><ul>
<li>Classe che modella una partita a <em>tris</em> (<em>Tic Tac Toe</em>)</li>
<li>Campi privati<ul>
<li>Matrice di gioco</li>
<li>Giocatore di turno: <code>O</code> oppure <code>X</code></li>
</ul>
</li>
<li>Metodi pubblici<ul>
<li>Mossa in una certa posizione <code>x, y</code> (simbolo scelto automaticamente nel metodo)</li>
<li>Rappresentazione stato: <code>__str__(self)</code></li>
</ul>
</li>
<li>Nel <code>main</code>, in un ciclo<ul>
<li>Chiedere all'utente le coordinate per la prossima mossa</li>
<li>Visualizzare lo stato risultante</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.7 Conclusione partita</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Aggiungere metodi alla classe del <em>tris</em><ul>
<li>Controllo di conclusione: <code>bool</code></li>
<li>Eventuale vincitore: <code>O</code>, <code>X</code>, <code>None</code></li>
<li><code>save</code> per salvare l'attuale partita in un file di testo</li>
<li><code>load</code> per caricare una partita da file</li>
</ul>
</li>
<li>Nel <code>main</code>, in un ciclo<ul>
<li>Chiedere all'utente le coordinate per la prossima mossa</li>
<li>In alternativa, permettere di salvare o caricare una partita</li>
<li>Visualizzare lo stato risultante</li>
<li>Comunicare l'eventuale conclusione della partita ed il vincitore</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.8 Espressioni</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Definire una gerarchia di classi per rappresentare espressioni matematiche</li>
<li>Una espressione (classe base astratta) può essere:<ul>
<li>Un literal (sottoclasse)</li>
<li>Una somma (sottoclasse)</li>
<li>Un prodotto (sottoclasse)</li>
</ul>
</li>
<li>La classe delle espressioni contiene un metodo astratto <code>eval</code><ul>
<li>Senza parametri, restituisce il valore dell'espressione</li>
</ul>
</li>
<li>Una costante contiene un valore <code>float</code></li>
<li>Somma e prodotto hanno due operandi, entrambi espressioni<ul>
<li>Gli operandi sono passati al costruttore</li>
</ul>
</li>
<li>Costruire (senza fare <em>parsing</em>!) gli oggetti che rappresentano la seguente espressione:<ul>
<li><code>5 * (4 + 3 * 2)</code>    - </li>
</ul>
</li>
<li>Calcolare il valore dell'espressione, chiamando <code>eval</code> sul nodo radice</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.9 Espressioni prefisse</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Aggiungere alla classe delle espressioni (es. 4.8) un metodo <code>prefix</code><ul>
<li>Genera una stringa che rappresenta l'espressione in notazione prefissa</li>
<li>Operatore seguito da operandi</li>
</ul>
</li>
<li>Rappresentazionbe prefissa dell'espressione dell'es. 4.8:<ul>
<li>
<ul>
<li>5 + 4 * 3 2</li>
</ul>
</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 5</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Progetto 1</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Gioco con diversi personaggi<ul>
<li>Fornita classe <code>Arena</code> per campo di gioco</li>
<li>Fornita classe base astratta <code>Actor</code> per personaggi</li>
</ul>
</li>
<li>Creare sottoclassi di <code>Actor</code> per personaggi specifici<ul>
<li><em>Polimorfismo</em> per movimento</li>
<li><em>Polimorfismo</em> per interazione reciproca</li>
</ul>
</li>
<li>Ma ciclo principale, interazione con l'utente e grafica <em>fuori da queste classi</em><ul>
<li>Funzionamento con grafica oppure con console testuale</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Pac-Man - Personaggi</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/pac-man.png">
        
      </figure><ul>
<li><em>Pac-Man</em><ul>
<li>Guidato dal giocatore, con la tastiera</li>
<li>Applica i comandi solo solo agli incroci</li>
</ul>
</li>
<li><em>Fantasmi</em><ul>
<li>Uccidono Pac-Man se lo toccano</li>
<li>Agli incroci svoltano casualmente</li>
<li>Ma non tornano mai indietro!</li>
</ul>
</li>
<li><em>Biscotti</em><ul>
<li>Pac-Man deve mangiarli tutti, per terminare il gioco</li>
</ul>
</li>
<li><em>SuperBiscotti</em><ul>
<li>Danno per breve tempo a Pac-Man il potere di mangiare i fantasmi</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Pac-Man - Controllo dei muri</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><em>Muri</em><ul>
<li>Possono essere <em>personaggi</em>, immobili</li>
<li>Non possono essere attraversati da nessuno</li>
<li>Sono già disegnati nell'immagine di sfondo (altrimenti, tracciare dei rettangoli pieni)</li>
<li>Disposti come blocchetti virtuali di <code>8x8</code> pixel, o multipli</li>
<li>Metà dimensione di Pac-Man e fantasmi (<code>16x16</code> pixel)</li>
</ul>
</li>
<li>I personaggi possono svoltare solo su coordinate multiple di <code>8x8</code> pixel!<ul>
<li>Se un personaggio urta un muro, si riposiziona fuori dal muro; annulla l'ultimo movimento (<code>dx, dy</code>)</li>
<li>È fornita una funzione per controllare <em>a priori</em> la presenza di un muro in una certa direzione</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 6</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Esercizi C++</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/cpp-logo.jpg">
        
      </figure><ul>
<li>1.1 Hello, user!</li>
<li>1.5 Tabella ASCII</li>
<li>1.9 La stanza del mostro</li>
<li>2.2 Conteggio caratteri</li>
<li>2.3 Funzione, ipotenusa</li>
<li>2.9 Crivello di Eratostene</li>
<li>3.6 Valori in file</li>
</ul>
<blockquote></blockquote>
<p>Es. 1.5 Stampare codice <code>i</code> come carattere: <code>cout &lt;&lt; char(i);</code></p>
<p>Es. 1.9 Valore casuale tra <code>0</code> e <code>4</code>: <code>r = rand() % 5;</code></p>
<p>Es. 2.2 Indice contatore per una cifra <code>val</code> (di tipo <code>char</code>): <code>val - '0'</code></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Pac-Man</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/pacman-scatter.png">
        
      </figure><ul>
<li>Distinguere tre comportamenti dei fantasmi (i primi due, alternati)<ul>
<li><em>Chase</em>: un fantasma sceglie un punto nei pressi di Pac-Man e cerca di avvicinarsi a quel punto</li>
<li><em>Scatter</em>: ogni fantasma pattuglia un angolo diverso (ognuno ha un suo obiettivo diverso a cui cerca continuamente di avvicinarsi)</li>
<li><em>Frightened</em>: i fantasmi si muovono in maniera casuale, quando Pac-Man ha i superpoteri</li>
</ul>
</li>
<li>I fantasmi non tornano comunque indietro</li>
</ul>
<blockquote></blockquote>
<p><a href="http://gameinternals.com/post/2072558330/understanding-pac-man-ghost-behavior">http://gameinternals.com/post/2072558330/understanding-pac-man-ghost-behavior</a></p>
<p><a href="http://www.gamasutra.com/view/feature/3938/the_pacman_dossier.php?print=1">http://www.gamasutra.com/view/feature/3938/the_pacman_dossier.php?print=1</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Pac-Man</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Controllare la <em>vittoria</em><ul>
<li>Tutti i biscotti sono stati mangiati</li>
</ul>
</li>
<li>Controllare la <em>sconfitta</em><ul>
<li>Pac-Man non è più in gioco, dopo essersi scontrato con un fantasma</li>
</ul>
</li>
<li>Creare una <em>sottoclasse di Arena</em>, specifica per il gioco di Pac-Man (es. <code>PacManArena</code>)<ul>
<li>Creare tutti i personaggi nel costruttore (<code>__init__</code>)</li>
<li>Includere nella classe i metodi per controllare lo stato del gioco</li>
<li>Includere nella classe i metodi per controllare preventivamente la presenza di muri attorno ai personaggi (<code>going_to_wall</code>...)</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 7</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Esercizi C++</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/cpp-logo.jpg">
        
      </figure><ul>
<li>2.5 Griglia di colori</li>
<li>3.4 Classe delle macchine</li>
<li>3.5 Lista di macchine</li>
<li>4.3 Attori astratti</li>
<li>4.8 Ultimo aggiornamento</li>
<li><strong>4.3 2013 - Tris</strong></li>
<li>4.4 2013 - Conclusione partita</li>
</ul>
<blockquote></blockquote>
<p>Es. 2.5 Partire dall'esempio <code>painter</code></p>
<p>Es. 3.4 Partire dall'esempio <code>anim</code></p>
<p>Es. 4.3 Gioco a console - Partire dagli esempi <code>fifteen</code> in C++, <code>tictactoe</code> in Python</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Pac-Man</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/pac-man.png">
        
      </figure><ul>
<li><em>Secondo Pac-Man</em><ul>
<li>Due giocatori, con l'uso di tasti diversi</li>
</ul>
</li>
<li><em>Opzionalmente...</em><ul>
<li>Punteggio, livelli, bonus ed estensioni <em>a fantasia</em></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>“Bella copia”</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/fair-copy.png">
        
      </figure><ul>
<li><strong>Codice leggibile</strong><ul>
<li><em>Costanti</em>, anzichè numeri “<em>magici</em>” sparsi nel codice</li>
<li><em>Nomi esplicativi</em> e semplici</li>
<li><em>Regole di stile</em>: <code>variable_name</code>, <code>function_name</code>, <code>ClassName</code>, <code>CONSTANT_NAME</code></li>
<li><em>Commenti</em>, quando utili: <em>function annotation</em>, <em>docstring</em></li>
</ul>
</li>
<li><strong>Codice ben organizzato</strong><ul>
<li><em>No copia&amp;incolla</em> del codice: funzioni parametrizzate e/o cicli</li>
<li><em>Programmazione strutturata</em>: preferibilmente <code>return</code> a fine funzione, cicli senza <code>break</code></li>
<li><em>OOP</em>: <em>incapsulamento</em>, <em>ereditarietà</em>, <em>polimorfismo</em></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 8</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Progetto 2</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Classe <em>C++</em> per incapsulare dati e regole di un gioco<ul>
<li>Campi <em>privati</em> + metodi <em>pubblici</em> (e privati)</li>
</ul>
</li>
<li>Interazione con l'utente tramite console oppure gui Qt...<ul>
<li>Ma ciclo principale, I/O, eventi, grafica <em>fuori dalla classe</em></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Slitherlink</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/slitherlink.png">
        
      </figure><ul>
<li>Regole<ul>
<li>Connect adjacent dots with vertical or horizontal lines to make a single loop</li>
<li>The numbers indicate how many lines surround it, while empty cells may be surrounded by any number of lines</li>
<li>The loop never crosses itself and never branches off</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p><a href="http://www.nikoli.com/en/puzzles/slitherlink/">http://www.nikoli.com/en/puzzles/slitherlink/</a></p>
<p><a href="https://www.brainbashers.com/slitherlinkhelp.asp">https://www.brainbashers.com/slitherlinkhelp.asp</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Slitherlink</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/slitherlink-solved.png">
        
      </figure><ul>
<li>Ad ogni mossa, permettere all'utente di scegliere una posizione dove:<ul>
<li>Aggiungere una linea (mostrare <code>-</code> o <code>|</code>)</li>
<li>Escluderne la presenza (mostrare <code>x</code>)</li>
<li>(L'utente posiziona liberamente le linee)</li>
</ul>
</li>
<li>Controllare il completamento del gioco<ul>
<li>I numeri indicano quante linee devono esserci attorno </li>
<li>Attorno ai segni <code>+</code> devono esserci <code>2</code> o <code>0</code> linee</li>
<li>(Solo inizialmente... trascurare la regola del "single loop")</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Bozza della classe</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="C++"><code>class Slitherlink {
public:
    Slitherlink();                  // default board
    void play_at(int x, int y);
    int cols() const {return cols_; }
    int rows() const { return rows_; }
    std::string get_val(int x, int y) const;
    bool finished() const;
    std::string message() const { return "Puzzle solved"; }
    // ...
private:
    // ...
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Esempio di campi privati</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="C++"><code>private:  // ...
  int cols_ = 11; int rows_ = 11;
  vector&lt; vector&lt;'char'&gt; &gt; board_ = {
    {'+', ' ', '+', ' ', '+', ' ', '+', ' ', '+', ' ', '+'},
    {' ', ' ', ' ', '3', ' ', '2', ' ', '2', ' ', ' ', ' '},
    {'+', ' ', '+', ' ', '+', ' ', '+', ' ', '+', ' ', '+'},
    {' ', ' ', ' ', '0', ' ', ' ', ' ', ' ', ' ', '2', ' '},
    {'+', ' ', '+', ' ', '+', ' ', '+', ' ', '+', ' ', '+'},
    {' ', ' ', ' ', '2', ' ', ' ', ' ', ' ', ' ', '1', ' '},
    {'+', ' ', '+', ' ', '+', ' ', '+', ' ', '+', ' ', '+'},
    {' ', ' ', ' ', '0', ' ', ' ', ' ', ' ', ' ', '2', ' '},
    {'+', ' ', '+', ' ', '+', ' ', '+', ' ', '+', ' ', '+'},
    {' ', ' ', ' ', '2', ' ', ' ', ' ', '2', ' ', ' ', ' '},
    {'+', ' ', '+', ' ', '+', ' ', '+', ' ', '+', ' ', '+'} };
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Funzionamento a console e gui</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/recycle.png">
        
      </figure><ul>
<li>Aggiungere una <em>interfaccia grafica</em> al progetto<ul>
<li>Fornita una gui che sfrutta l'astrazione <code>Game</code></li>
</ul>
</li>
<li>Permettere all'utente di giocare tramite <em>console</em><ul>
<li>Mantenere le operazioni di I/O fuori dalla classe</li>
</ul>
</li>
<li>Inoltre, permettere di salvare o caricare una partita<ul>
<li>Lettura e scrittura su <em>stream</em> nella classe del puzzle</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 9</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Mossa suggerita</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/artificial-intelligence.png">
        
      </figure><ul>
<li>Comando per completare automaticamente un incrocio (<code>+</code>):<ul>
<li>Es. manca solo una casella → linea o <code>x</code></li>
<li>Es. ci sono già due linee → tutte <code>x</code></li>
</ul>
</li>
<li>Comando per completare automaticamente un vincolo numerico<ul>
<li>Es. ci sono già le linee giuste → tutte <code>x</code></li>
<li>Es. mancano <code>n</code> linee e ci sono <code>n</code> caselle libere → tutte linee</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Autocompletamento su richiesta dell'utente (es. click su cella, o menù)</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Vicolo cieco (opzionale)</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/dead-end.jpg">
        
      </figure><ul>
<li>Aggiungere un metodo booleano <code>wrong</code> al puzzle, per verificare una condizione di vicolo cieco<ul>
<li>Impossibile risolvere il puzzle, senza <em>rimuovere</em> un simbolo (linea o <code>x</code>)</li>
<li><em>Attenzione</em>: condizione più stringente di <code>not finished</code></li>
<li>Almeno un vincolo violato per eccesso di linee, oppure di <code>x</code></li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Una delle cause possibili (ma non la sola): un circuito chiuso non include tutte le linee</p>
<p>Effettuare la verifica su richiesta dell'utente (es. tramite menù)</p></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 10</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Ulteriori suggerimenti (opzionale)</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Ragionare come un giocatore umano (senza <em>backtracking</em>!)<ul>
<li><a href="https://www.brainbashers.com/slitherlinkhelp.asp">https://www.brainbashers.com/slitherlinkhelp.asp</a></li>
</ul>
</li>
<li>In una singola cella, provare i due segni alternativi (linea o <code>x</code>)<ul>
<li>Operare su due copie del gioco</li>
<li>Su ciascuna copia, applicare tutti gli autocompletamenti possibili (scorsa esercitazione)</li>
<li>Se si finisce in un vicolo cieco (<code>wrong</code>), allora il segno giusto è l'altro</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="C++"><code>auto copy1 = *this; copy1.board_[y][x] = '-'; copy1.autocomplete();
auto copy2 = *this; copy2.board_[y][x] = 'x'; copy2.autocomplete();
</code></pre>
<blockquote></blockquote>
<p>Ulteriore possibilità: se entrambe le opzioni determinano uno stesso segno in una certa altra posizione, allora fissare quel segno nella sua posizione</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Soluzione ricorsiva (opzionale)</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="C++"><code>bool Slitherlink::solve_recursive() {
    // solve_simple();
    complex&lt;int&gt; pos = find_first_playable();  // Cartesian coord
    if (pos.real() &gt;= 0 &amp;&amp; pos.imag() &gt;= 0 &amp;&amp; !wrong()) {
        auto copy = *this;  // save current status
        for (auto sign : {'-', 'x'}) {
            board_[pos.imag()][pos.real()] = sign;
            if (solve_recursive()) return true;
            *this = copy;  // backtracking
        }
    }
    return finished();
}
</code></pre>
<blockquote></blockquote>
<p>Il metodo <code>find_first_playable</code> cerca la prima casella giocabile, non già segnata</p>
<p>Opzionalmente, <code>solve_simple</code> applica prima tutte (!) le altre strategie di soluzione</p></article>
 
</slide>


<slide class="thank-you-slide segue nobackground">
  <aside class="gdbar right"><img src="images/logo.png"></aside>
  <article class="flexbox vleft auto-fadein">
    <h2>&lt;Domande?&gt;</h2>
  </article>
  <p class="auto-fadein" data-config-contact>
    Michele Tomaiuolo
    <br>
    Palazzina 1, int. 5708
    <br>
    Ingegneria dell'Informazione, UniPR
    <br>
    <a href="http://www.ce.unipr.it/people/tomamic">www.ce.unipr.it/people/tomamic</a>
  </p>
</slide>

<slide class="backdrop"></slide>

</slides>

</body>
</html>